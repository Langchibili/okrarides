// lib/contexts/ReactNativeWrapper.js
'use client';

import React, { createContext, useContext, useEffect, useState, useRef, useCallback } from 'react';

const ReactNativeContext = createContext(null);

export const useReactNative = () => {
  const context = useContext(ReactNativeContext);
  if (!context) {
    throw new Error('useReactNative must be used within ReactNativeWrapper');
  }
  return context;
};

export function ReactNativeWrapper({ children }) {
  const [isNative, setIsNative] = useState(false);
  const [isChecking, setIsChecking] = useState(true);
  const [permissions, setPermissions] = useState({
    location: null,
    notification: null,
    drawOver: null
  });
  const [deviceInfo, setDeviceInfo] = useState(null);
  const [servicesInitialized, setServicesInitialized] = useState(false);
  const [currentFrontend, setCurrentFrontend] = useState(null);
  
  const checkTimeoutRef = useRef(null);
  const messageHandlersRef = useRef(new Map());
  const pendingRequestsRef = useRef(new Map());
  const requestIdCounterRef = useRef(0);

  // Check if running in React Native WebView
  // This runs on EVERY page (landing page, rider app, driver app, etc.)
  // but does NOT initialize services yet
  useEffect(() => {
    let checkCount = 0;
    const maxChecks = 180; // 3 minutes at 1 second intervals

    const checkNativeEnvironment = () => {
      const isRNWebView = typeof window !== 'undefined' && 
                         !!window.ReactNativeWebView;

      if (isRNWebView) {
        setIsNative(true);
        setIsChecking(false);
        if (checkTimeoutRef.current) {
          clearInterval(checkTimeoutRef.current);
          checkTimeoutRef.current = null;
        }
        console.log('âœ… React Native WebView detected');
        
        // Detect which frontend we're on based on URL
        detectCurrentFrontend();
      } else {
        checkCount++;
        if (checkCount >= maxChecks) {
          setIsNative(false);
          setIsChecking(false);
          if (checkTimeoutRef.current) {
            clearInterval(checkTimeoutRef.current);
            checkTimeoutRef.current = null;
          }
          console.log('â„¹ï¸ Running in web browser (not React Native)');
        }
      }
    };

    // Initial check
    checkNativeEnvironment();

    // Continue checking if not found yet
    if (!isNative && isChecking) {
      checkTimeoutRef.current = setInterval(checkNativeEnvironment, 1000);
    }

    return () => {
      if (checkTimeoutRef.current) {
        clearInterval(checkTimeoutRef.current);
      }
    };
  }, []);

  // Detect which frontend we're currently on
  const detectCurrentFrontend = useCallback(() => {
    if (typeof window === 'undefined') return null;
    
    const hostname = window.location.hostname;
    const pathname = window.location.pathname;
    
    // Check subdomain or path to determine frontend
    if (hostname.includes('driver.') || pathname.includes('/driver')) {
      setCurrentFrontend('driver');
      return 'driver';
    } else if (hostname.includes('book.') || hostname.includes('rider.') || pathname.includes('/rider')) {
      setCurrentFrontend('rider');
      return 'rider';
    } else if (hostname.includes('conductor.') || pathname.includes('/conductor')) {
      setCurrentFrontend('conductor');
      return 'conductor';
    } else if (hostname.includes('delivery.') || pathname.includes('/delivery')) {
      setCurrentFrontend('delivery');
      return 'delivery';
    } else if (hostname.includes('admin.') || pathname.includes('/admin')) {
      setCurrentFrontend('admin');
      return 'admin';
    } else {
      // Landing page or unknown
      setCurrentFrontend('landing');
      return 'landing';
    }
  }, []);

  // Listen for URL changes (when user navigates to different frontends)
  useEffect(() => {
    if (typeof window === 'undefined' || !isNative) return;

    // Listen for navigation within WebView
    const handleUrlChange = () => {
      const newFrontend = detectCurrentFrontend();
      console.log('ðŸ“ Navigated to frontend:', newFrontend);
    };

    // Check URL periodically (WebView navigation doesn't trigger normal events)
    const urlCheckInterval = setInterval(handleUrlChange, 1000);

    return () => clearInterval(urlCheckInterval);
  }, [isNative, detectCurrentFrontend]);

  // Setup message listener for responses from native
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handleMessage = (event) => {
      try {
        const data = typeof event.data === 'string' 
          ? JSON.parse(event.data) 
          : event.data;

        const { type, requestId, payload, error } = data;

        // Handle pending request responses
        if (requestId && pendingRequestsRef.current.has(requestId)) {
          const { resolve, reject } = pendingRequestsRef.current.get(requestId);
          pendingRequestsRef.current.delete(requestId);

          if (error) {
            reject(new Error(error));
          } else {
            resolve(payload);
          }
          return;
        }

        // Handle event-based messages
        const handlers = messageHandlersRef.current.get(type);
        if (handlers) {
          handlers.forEach(handler => handler(payload));
        }

        // Handle specific message types
        switch (type) {
          case 'PERMISSION_RESULT':
            setPermissions(prev => ({
              ...prev,
              [payload.permissionType]: payload.status
            }));
            break;

          case 'DEVICE_INFO':
            setDeviceInfo(payload);
            break;

          case 'LOCATION_UPDATE':
            // Handled by registered handlers
            break;

          default:
            console.log('Received message from native:', type, payload);
        }
      } catch (error) {
        console.error('Error handling message from native:', error);
      }
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, []);

  // Send message to native with promise support
  const sendToNative = useCallback((type, payload = {}) => {
    return new Promise((resolve, reject) => {
      if (!isNative || !window.ReactNativeWebView) {
        reject(new Error('Not running in React Native environment'));
        return;
      }

      const requestId = `req_${++requestIdCounterRef.current}_${Date.now()}`;
      
      // Store promise handlers
      pendingRequestsRef.current.set(requestId, { resolve, reject });

      // Set timeout for request
      setTimeout(() => {
        if (pendingRequestsRef.current.has(requestId)) {
          pendingRequestsRef.current.delete(requestId);
          reject(new Error(`Request timeout: ${type}`));
        }
      }, 30000); // 30 second timeout

      // Send to native
      window.ReactNativeWebView.postMessage(JSON.stringify({
        type,
        requestId,
        payload
      }));
    });
  }, [isNative]);

  // Register event handler
  const on = useCallback((type, handler) => {
    if (!messageHandlersRef.current.has(type)) {
      messageHandlersRef.current.set(type, new Set());
    }
    messageHandlersRef.current.get(type).add(handler);

    // Return unsubscribe function
    return () => {
      const handlers = messageHandlersRef.current.get(type);
      if (handlers) {
        handlers.delete(handler);
      }
    };
  }, []);

  // Request permission (works for both web and native)
  const requestPermission = useCallback(async (permissionType) => {
    if (isNative) {
      // Native permission request
      try {
        const result = await sendToNative('REQUEST_PERMISSION', { permissionType });
        setPermissions(prev => ({
          ...prev,
          [permissionType]: result.status
        }));
        return result.status;
      } catch (error) {
        console.error(`Error requesting ${permissionType} permission:`, error);
        return 'denied';
      }
    } else {
      // Web permission request
      if (permissionType === 'location') {
        try {
          const result = await navigator.permissions.query({ name: 'geolocation' });
          if (result.state === 'granted' || result.state === 'prompt') {
            return new Promise((resolve) => {
              navigator.geolocation.getCurrentPosition(
                () => {
                  setPermissions(prev => ({ ...prev, location: 'granted' }));
                  resolve('granted');
                },
                () => {
                  setPermissions(prev => ({ ...prev, location: 'denied' }));
                  resolve('denied');
                }
              );
            });
          }
          return result.state;
        } catch (error) {
          console.error('Error requesting location permission:', error);
          return 'denied';
        }
      } else if (permissionType === 'notification') {
        try {
          const permission = await Notification.requestPermission();
          setPermissions(prev => ({ ...prev, notification: permission }));
          return permission;
        } catch (error) {
          console.error('Error requesting notification permission:', error);
          return 'denied';
        }
      }
      return 'unsupported';
    }
  }, [isNative, sendToNative]);

  // Initialize native services (called after authentication)
  const initializeNativeServices = useCallback(async (userId, frontendName, socketServerUrl) => {
    if (!isNative) {
      console.log('Not in native environment, skipping native initialization');
      return { success: false, reason: 'not_native' };
    }

    // Prevent duplicate initialization
    if (servicesInitialized) {
      console.log('âš ï¸ Native services already initialized');
      return { success: true, reason: 'already_initialized' };
    }

    try {
      console.log(`ðŸš€ Initializing native services for ${frontendName}...`);
      
      const result = await sendToNative('INITIALIZE_SERVICES', {
        userId,
        frontendName,
        socketServerUrl: socketServerUrl || process.env.NEXT_PUBLIC_DEVICE_SOCKET_URL
      });

      console.log('âœ… Native services initialized:', result);
      setServicesInitialized(true);
      setCurrentFrontend(frontendName);
      
      return { success: true, ...result };
    } catch (error) {
      console.error('âŒ Error initializing native services:', error);
      return { success: false, error: error.message };
    }
  }, [isNative, servicesInitialized, sendToNative]);

  // Request current location
  const getCurrentLocation = useCallback(async () => {
    if (isNative) {
      return sendToNative('GET_CURRENT_LOCATION', {});
    } else {
      // Web geolocation API
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolocation not supported'));
          return;
        }

        navigator.geolocation.getCurrentPosition(
          (position) => {
            resolve({
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              accuracy: position.coords.accuracy,
              heading: position.coords.heading,
              speed: position.coords.speed,
              timestamp: position.timestamp
            });
          },
          (error) => reject(error),
          { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
      });
    }
  }, [isNative, sendToNative]);

  // Start location tracking
  const startLocationTracking = useCallback(async (interval = 5000) => {
    if (isNative) {
      return sendToNative('START_LOCATION_TRACKING', { interval });
    } else {
      // Web location tracking
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolocation not supported'));
          return;
        }

        const watchId = navigator.geolocation.watchPosition(
          (position) => {
            const handlers = messageHandlersRef.current.get('LOCATION_UPDATE');
            if (handlers) {
              const locationData = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy,
                heading: position.coords.heading,
                speed: position.coords.speed,
                timestamp: position.timestamp
              };
              handlers.forEach(handler => handler(locationData));
            }
          },
          (error) => console.error('Location tracking error:', error),
          { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );

        resolve({ watchId });
      });
    }
  }, [isNative, sendToNative]);

  // Stop location tracking
  const stopLocationTracking = useCallback(async () => {
    if (isNative) {
      return sendToNative('STOP_LOCATION_TRACKING', {});
    } else {
      // Web: handled by individual frontends storing watchId
      return Promise.resolve();
    }
  }, [isNative, sendToNative]);

  // Show notification
  const showNotification = useCallback(async (notification) => {
    if (isNative) {
      return sendToNative('SHOW_NOTIFICATION', notification);
    } else {
      // Web notification
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(notification.title, {
          body: notification.body,
          icon: notification.icon,
          badge: notification.badge,
          data: notification.data
        });
        return Promise.resolve({ shown: true });
      }
      return Promise.resolve({ shown: false, reason: 'permission_denied' });
    }
  }, [isNative, sendToNative]);

  // Check permission status
  const checkPermission = useCallback(async (permissionType) => {
    if (isNative) {
      try {
        const result = await sendToNative('CHECK_PERMISSION', { permissionType });
        setPermissions(prev => ({
          ...prev,
          [permissionType]: result.status
        }));
        return result.status;
      } catch (error) {
        return 'denied';
      }
    } else {
      // Web permission check
      if (permissionType === 'location') {
        try {
          const result = await navigator.permissions.query({ name: 'geolocation' });
          return result.state;
        } catch {
          return 'prompt';
        }
      } else if (permissionType === 'notification') {
        return Notification.permission;
      }
      return 'unsupported';
    }
  }, [isNative, sendToNative]);

  const value = {
    isNative,
    isChecking,
    permissions,
    deviceInfo,
    servicesInitialized,
    currentFrontend,
    sendToNative,
    on,
    requestPermission,
    initializeNativeServices,
    getCurrentLocation,
    startLocationTracking,
    stopLocationTracking,
    showNotification,
    checkPermission
  };

  return (
    <ReactNativeContext.Provider value={value}>
      {children}
    </ReactNativeContext.Provider>
  );
}

export default ReactNativeWrapper;